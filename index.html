<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>iTunes Replica Player with Shuffle & Repeat</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* Reset & basics */
    * {
      box-sizing: border-box;
    }
    body, html {
      margin: 0; padding: 0; height: 100%; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
        Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
      background: #121212;
      color: #eee;
      display: flex;
      flex-direction: column;
      user-select: none;
      transition: background 0.3s, color 0.3s;
      overflow: hidden;
    }
    body.light {
      background: #f9f9f9;
      color: #111;
    }

    /* Header */
    header {
      padding: 12px 20px;
      background: #181818;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #333;
    }
    body.light header {
      background: #fff;
      border-color: #ccc;
      color: #111;
    }
    header h1 {
      margin: 0;
      font-weight: 700;
      font-size: 22px;
      color: #1db954;
      user-select: text;
    }
    #toggleThemeBtn {
      background: #1db954;
      border: none;
      padding: 8px 16px;
      font-weight: 700;
      color: #000;
      border-radius: 20px;
      cursor: pointer;
      user-select: none;
      transition: background 0.3s;
    }
    #toggleThemeBtn:hover {
      background: #17a44c;
    }

    /* Layout */
    main {
      flex: 1;
      display: flex;
      height: calc(100vh - 56px);
      overflow: hidden;
    }
    aside {
      width: 280px;
      background: #000;
      padding: 20px 10px;
      border-right: 1px solid #333;
      display: flex;
      flex-direction: column;
      transition: background 0.3s, color 0.3s;
      overflow-y: auto;
    }
    body.light aside {
      background: #f0f0f0;
      border-color: #ccc;
      color: #111;
    }
    aside h2 {
      color: #1db954;
      margin: 0 0 15px 0;
      font-weight: 900;
      font-size: 22px;
      text-align: center;
      user-select: text;
    }
    aside button {
      background: none;
      border: none;
      color: #b3b3b3;
      padding: 10px 20px;
      text-align: left;
      font-size: 16px;
      cursor: pointer;
      border-radius: 6px;
      margin-bottom: 6px;
      transition: color 0.2s, background 0.2s;
    }
    aside button:hover,
    aside button.active {
      background: #1db954;
      color: #000;
      font-weight: 700;
    }

    /* Section */
    section {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    #searchBar {
      padding: 10px 20px;
      border-bottom: 1px solid #333;
      background: #181818;
      transition: background 0.3s;
    }
    body.light #searchBar {
      background: #fff;
      border-color: #ccc;
    }
    #searchInput {
      width: 100%;
      padding: 8px 12px;
      font-size: 16px;
      border-radius: 20px;
      border: none;
      background: #282828;
      color: #eee;
      outline: none;
      transition: background 0.3s, color 0.3s;
    }
    body.light #searchInput {
      background: #eee;
      color: #111;
    }

    /* Table container */
    #songTableContainer {
      flex: 1;
      overflow-y: auto;
      background: #121212;
      transition: background 0.3s;
      min-width: 600px;
    }
    body.light #songTableContainer {
      background: #f9f9f9;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      user-select: none;
    }
    thead tr {
      border-bottom: 1px solid #333;
      cursor: pointer;
      user-select: none;
    }
    body.light thead tr {
      border-color: #ccc;
    }
    thead th {
      color: #bbb;
      padding: 12px 15px;
      font-weight: 600;
      text-align: left;
      font-size: 13px;
      position: sticky;
      top: 0;
      background: inherit;
      z-index: 2;
    }
    tbody tr {
      border-bottom: 1px solid #282828;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
    }
    body.light tbody tr {
      border-color: #ddd;
    }
    tbody tr:hover {
      background: #1db954;
      color: #000;
      font-weight: 700;
    }
    tbody tr.selected {
      background: #1db954;
      color: #000;
      font-weight: 700;
    }
    tbody td {
      padding: 12px 15px;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      font-size: 14px;
    }
    td.duration {
      text-align: right;
      font-variant-numeric: tabular-nums;
    }

    /* Now Playing bar */
    #nowPlayingBar {
      height: 110px;
      background: #181818;
      border-top: 1px solid #333;
      color: #eee;
      display: flex;
      align-items: center;
      padding: 0 20px;
      gap: 20px;
      user-select: none;
      transition: background 0.3s, color 0.3s;
      flex-wrap: wrap;
      position: relative;
    }
    body.light #nowPlayingBar {
      background: #f9f9f9;
      border-color: #ccc;
      color: #111;
    }
    #nowPlayingInfo {
      flex: 1;
      min-width: 220px;
      overflow: hidden;
    }
    #nowPlayingTitle {
      font-weight: 700;
      font-size: 20px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      margin-bottom: 4px;
    }
    #nowPlayingArtistAlbum {
      font-size: 14px;
      color: #888;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    body.light #nowPlayingArtistAlbum {
      color: #666;
    }

    /* Player Controls */
    #playerControls {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-shrink: 0;
      flex-wrap: wrap;
    }
    #playerControls button {
      background: none;
      border: none;
      color: inherit;
      font-size: 28px;
      cursor: pointer;
      transition: color 0.3s;
      user-select: none;
      padding: 4px 8px;
      position: relative;
      min-width: 42px;
      min-height: 42px;
      border-radius: 6px;
    }
    #playerControls button:hover {
      color: #1db954;
      background-color: rgba(29, 185, 84, 0.15);
    }

    /* Progress bar */
    #progressContainer {
      flex-grow: 2;
      min-width: 250px;
      user-select: none;
      display: flex;
      flex-direction: column;
      max-width: 600px;
    }
    #progressBar {
      width: 100%;
      height: 6px;
      background: #333;
      border-radius: 4px;
      cursor: pointer;
      position: relative;
      margin-bottom: 6px;
    }
    #progressFilled {
      height: 100%;
      background: #1db954;
      border-radius: 4px;
      width: 0%;
      transition: width 0.1s linear;
    }
    #timeContainer {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: #888;
    }
    body.light #timeContainer {
      color: #666;
    }

    /* Volume */
    #volumeContainer {
      width: 160px;
      display: flex;
      align-items: center;
      gap: 6px;
      flex-shrink: 0;
    }
    #volumeIcon {
      font-size: 22px;
      user-select: none;
      cursor: pointer;
      user-select: none;
      color: inherit;
      transition: color 0.3s;
    }
    #volumeIcon:hover {
      color: #1db954;
    }
    #volumeSlider {
      flex-grow: 1;
      cursor: pointer;
    }

    /* EQ Dropdown styling */
    #eqDropdown {
      position: absolute;
      bottom: 110px;
      right: 20px;
      width: 320px;
      background: #181818;
      border: 1px solid #1db954;
      border-radius: 12px;
      padding: 15px;
      color: #eee;
      box-shadow: 0 0 15px #1db954aa;
      display: none;
      user-select: none;
      z-index: 1000;
      transition: opacity 0.3s ease;
    }
    body.light #eqDropdown {
      background: #f9f9f9;
      color: #111;
      border-color: #17a44c;
      box-shadow: 0 0 15px #17a44caa;
    }
    #eqDropdown header {
      font-weight: 700;
      font-size: 16px;
      margin-bottom: 10px;
      user-select: none;
    }
    .eqSliderContainer {
      display: flex;
      flex-direction: column;
      margin-bottom: 12px;
    }
    .eqSliderContainer label {
      font-size: 14px;
      margin-bottom: 4px;
      user-select: text;
    }
    .eqSliderContainer input[type=range] {
      width: 100%;
      cursor: pointer;
    }

    /* Sort indicator */
    .sortable:hover {
      color: #1db954;
      cursor: pointer;
    }
    .sorted-asc::after {
      content: " ‚ñ≤";
      font-size: 10px;
      color: #1db954;
    }
    .sorted-desc::after {
      content: " ‚ñº";
      font-size: 10px;
      color: #1db954;
    }

    /* Queue container */
    #queueContainer {
      margin-top: 20px;
      background: #222;
      padding: 10px;
      border-radius: 10px;
      color: #ccc;
      font-size: 14px;
      max-height: 140px;
      overflow-y: auto;
      user-select: none;
    }
    body.light #queueContainer {
      background: #eee;
      color: #111;
    }
    #queueContainer h3 {
      margin: 0 0 8px 0;
      font-weight: 700;
      font-size: 16px;
      color: #1db954;
      user-select: text;
    }
    #queueList {
      list-style: none;
      margin: 0;
      padding: 0;
    }
    #queueList li {
      padding: 4px 6px;
      cursor: pointer;
      border-radius: 6px;
      transition: background 0.2s;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #queueList li:hover {
      background: #1db954;
      color: #000;
      font-weight: 700;
    }
    #queueList li.active {
      background: #1db954;
      color: #000;
      font-weight: 700;
    }

    /* Scrollbar styling */
    #songTableContainer::-webkit-scrollbar,
    #queueContainer::-webkit-scrollbar,
    aside::-webkit-scrollbar {
      width: 8px;
    }
    #songTableContainer::-webkit-scrollbar-thumb,
    #queueContainer::-webkit-scrollbar-thumb,
    aside::-webkit-scrollbar-thumb {
      background: #1db954;
      border-radius: 10px;
    }

  </style>
</head>
<body>
  <header>
    <h1>iTunes Replica</h1>
    <button id="toggleThemeBtn" aria-label="Toggle Light or Dark Theme">Toggle Light/Dark</button>
  </header>

  <main>
    <aside>
      <h2>Library</h2>
      <button id="btnLoadSongs" class="active" aria-pressed="true">All Songs</button>
      <!-- Future playlists can go here -->
      <div id="queueContainer" aria-label="Playback Queue" tabindex="0">
        <h3>Up Next</h3>
        <ul id="queueList" role="list"></ul>
      </div>
    </aside>

    <section>
      <div id="searchBar">
        <input id="searchInput" type="search" placeholder="Search songs..." autocomplete="off" aria-label="Search songs" />
      </div>
      <div id="songTableContainer" tabindex="0" aria-label="Song list">
        <table id="songTable" cellspacing="0" cellpadding="0" aria-describedby="searchBar">
          <thead>
            <tr>
              <th class="name sortable" tabindex="0" role="button" aria-sort="none" data-sort="name">Title</th>
              <th class="artist sortable" tabindex="0" role="button" aria-sort="none" data-sort="artist">Artist</th>
              <th class="album sortable" tabindex="0" role="button" aria-sort="none" data-sort="album">Album</th>
              <th class="duration sortable" tabindex="0" role="button" aria-sort="none" data-sort="duration">Duration</th>
            </tr>
          </thead>
          <tbody id="songTableBody" tabindex="0"></tbody>
        </table>
      </div>
    </section>
  </main>

  <div id="nowPlayingBar" role="region" aria-live="polite" aria-label="Now Playing">
    <div id="nowPlayingInfo">
      <div id="nowPlayingTitle">No song playing</div>
      <div id="nowPlayingArtistAlbum"></div>
    </div>
    <div id="playerControls" aria-label="Player controls">
      <button id="btnPrev" title="Previous" aria-label="Previous track">‚èÆÔ∏è</button>
      <button id="btnPlayPause" title="Play/Pause" aria-label="Play or pause">‚ñ∂Ô∏è</button>
      <button id="btnNext" title="Next" aria-label="Next track">‚è≠Ô∏è</button>
      <button id="btnShuffle" title="Shuffle" aria-label="Toggle shuffle">üîÄ</button>
      <button id="btnRepeat" title="Repeat Mode" aria-label="Change repeat mode">üîÅ</button>
      <button id="eqToggleBtn" title="Equalizer" aria-haspopup="true" aria-expanded="false" aria-controls="eqDropdown">EQ</button>
    </div>
    <div id="progressContainer">
      <div id="progressBar" aria-label="Progress Bar" role="progressbar" tabindex="0" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
        <div id="progressFilled"></div>
      </div>
      <div id="timeContainer">
        <span id="currentTime">0:00</span>
        <span id="durationTime">0:00</span>
      </div>
    </div>
    <div id="volumeContainer">
      <div id="volumeIcon" aria-label="Volume level" title="Toggle mute">üîä</div>
      <input id="volumeSlider" type="range" min="0" max="1" step="0.01" value="0.7" aria-label="Volume control" />
    </div>
  </div>

  <!-- Equalizer Dropdown -->
  <div id="eqDropdown" role="dialog" aria-modal="false" aria-labelledby="eqDropdownHeader" tabindex="-1">
    <header id="eqDropdownHeader">Equalizer</header>
    <div class="eqSliderContainer">
      <label for="bassSlider">Bass</label>
      <input type="range" id="bassSlider" min="-15" max="15" value="0" />
    </div>
    <div class="eqSliderContainer">
      <label for="trebleSlider">Treble</label>
      <input type="range" id="trebleSlider" min="-15" max="15" value="0" />
    </div>
  </div>

  <audio id="audio" crossorigin="anonymous"></audio>

  <!-- jsmediatags lib for metadata reading -->
  <script src="https://cdn.jsdelivr.net/npm/jsmediatags@3.9.5/dist/jsmediatags.min.js"></script>

  <script>
    // Your Google Drive API key and folder ID here:
    const API_KEY = 'AIzaSyDsYE91yeURK3t8Ks1m4FA25rRN6O9pNmM'; // replace with your API key
    const FOLDER_ID = '1Q7W4e3eYZL6f8gh8tMvLP4BzVjhFg9sG'; // replace with your folder ID

    // DOM elements
    const songTableBody = document.getElementById('songTableBody');
    const searchInput = document.getElementById('searchInput');
    const btnPlayPause = document.getElementById('btnPlayPause');
    const btnPrev = document.getElementById('btnPrev');
    const btnNext = document.getElementById('btnNext');
    const btnShuffle = document.getElementById('btnShuffle');
    const btnRepeat = document.getElementById('btnRepeat');
    const eqToggleBtn = document.getElementById('eqToggleBtn');
    const eqDropdown = document.getElementById('eqDropdown');
    const bassSlider = document.getElementById('bassSlider');
    const trebleSlider = document.getElementById('trebleSlider');
    const nowPlayingTitle = document.getElementById('nowPlayingTitle');
    const nowPlayingArtistAlbum = document.getElementById('nowPlayingArtistAlbum');
    const progressBar = document.getElementById('progressBar');
    const progressFilled = document.getElementById('progressFilled');
    const currentTimeEl = document.getElementById('currentTime');
    const durationTimeEl = document.getElementById('durationTime');
    const volumeSlider = document.getElementById('volumeSlider');
    const volumeIcon = document.getElementById('volumeIcon');
    const toggleThemeBtn = document.getElementById('toggleThemeBtn');
    const queueList = document.getElementById('queueList');

    const audio = document.getElementById('audio');

    // Playback state
    let tracks = [];
    let filteredTracks = [];
    let queue = [];
    let currentTrackIndex = -1; // index in filteredTracks, NOT queue
    let isPlaying = false;
    let isShuffle = false;
    let repeatMode = 'none'; // 'none', 'all', 'one'
    let audioCtx, sourceNode, bassFilter, trebleFilter;

    // Sorting state
    let sortField = 'name';
    let sortDirection = 'asc';

    // Initialize Web Audio API context and EQ filters
    function setupAudioContext() {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      sourceNode = audioCtx.createMediaElementSource(audio);
      bassFilter = audioCtx.createBiquadFilter();
      bassFilter.type = "lowshelf";
      bassFilter.frequency.setValueAtTime(200, audioCtx.currentTime);
      trebleFilter = audioCtx.createBiquadFilter();
      trebleFilter.type = "highshelf";
      trebleFilter.frequency.setValueAtTime(3000, audioCtx.currentTime);

      sourceNode.connect(bassFilter);
      bassFilter.connect(trebleFilter);
      trebleFilter.connect(audioCtx.destination);
    }

    // Load all songs from Google Drive folder (handle pagination)
    async function loadSongsFromDrive() {
      tracks = [];
      let nextPageToken = '';
      try {
        do {
          let url = `https://www.googleapis.com/drive/v3/files?q='${FOLDER_ID}'+in+parents+and+mimeType contains 'audio/'&fields=nextPageToken,files(id,name,mimeType)&key=${API_KEY}&pageSize=100`;
          if (nextPageToken) url += `&pageToken=${nextPageToken}`;

          const res = await fetch(url);
          if (!res.ok) throw new Error(`Drive API Error: ${res.status}`);
          const data = await res.json();

          for (const file of data.files) {
            const url = `https://drive.google.com/uc?export=download&id=${file.id}`;
            tracks.push({
              id: file.id,
              name: file.name.replace(/\.[^/.]+$/, ""), // strip extension
              url,
              artist: "Unknown",
              album: "Unknown",
              duration: 0,
              _metaLoaded: false
            });
          }
          nextPageToken = data.nextPageToken || '';
        } while (nextPageToken);
      } catch (err) {
        console.error('Failed to load songs:', err);
        alert('Failed to load songs from Google Drive API. Check console.');
      }
    }

    // Render the song list with sorting and filtering
    function renderSongList() {
      filteredTracks.sort((a, b) => {
        let fa = a[sortField] || '';
        let fb = b[sortField] || '';
        if (sortField === 'duration') {
          fa = Number(fa) || 0;
          fb = Number(fb) || 0;
        } else {
          fa = fa.toString().toLowerCase();
          fb = fb.toString().toLowerCase();
        }
        if (fa < fb) return sortDirection === 'asc' ? -1 : 1;
        if (fa > fb) return sortDirection === 'asc' ? 1 : -1;
        return 0;
      });

      songTableBody.innerHTML = '';
      filteredTracks.forEach((track, idx) => {
        const tr = document.createElement('tr');
        tr.className = (idx === currentTrackIndex) ? 'selected' : '';
        tr.tabIndex = 0;
        tr.setAttribute('role', 'row');
        tr.onclick = () => {
          playTrack(idx);
          addToQueue(idx);
        };
        tr.onkeydown = e => { if (e.key === 'Enter') playTrack(idx); };

        const tdName = document.createElement('td');
        tdName.className = 'name';
        tdName.textContent = track.name;
        tr.appendChild(tdName);

        const tdArtist = document.createElement('td');
        tdArtist.className = 'artist';
        tdArtist.textContent = track.artist;
        tr.appendChild(tdArtist);

        const tdAlbum = document.createElement('td');
        tdAlbum.className = 'album';
        tdAlbum.textContent = track.album;
        tr.appendChild(tdAlbum);

        const tdDuration = document.createElement('td');
        tdDuration.className = 'duration';
        tdDuration.textContent = formatDuration(track.duration);
        tr.appendChild(tdDuration);

        songTableBody.appendChild(tr);
      });
    }

    // Format seconds to mm:ss
    function formatDuration(seconds) {
      if (!seconds || isNaN(seconds)) return '0:00';
      const m = Math.floor(seconds / 60);
      const s = Math.floor(seconds % 60);
      return `${m}:${s.toString().padStart(2, '0')}`;
    }

    // Play a track by index in filteredTracks
    async function playTrack(idx) {
      if (idx < 0 || idx >= filteredTracks.length) return;
      currentTrackIndex = idx;
      const track = filteredTracks[idx];

      if (!track._metaLoaded) {
        await loadMetadata(track);
      }

      // Use Web Audio context if suspended
      if (audioCtx.state === 'suspended') await audioCtx.resume();

      audio.src = track.url;
      try {
        await audio.play();
        isPlaying = true;
        updateNowPlaying(track);
        renderSongList();
        btnPlayPause.textContent = '‚è∏Ô∏è';
        highlightQueueCurrent();
      } catch (e) {
        console.error('Playback error:', e);
        alert('Error playing audio. Try another track.');
      }
    }

    // Load metadata using jsmediatags, fallback to audio element duration
    async function loadMetadata(track) {
      return new Promise((resolve) => {
        jsmediatags.read(track.url, {
          onSuccess: (tag) => {
            const tags = tag.tags;
            if (tags.title) track.name = tags.title;
            if (tags.artist) track.artist = tags.artist;
            if (tags.album) track.album = tags.album;

            // Attempt to get duration
            const tempAudio = new Audio(track.url);
            tempAudio.addEventListener('loadedmetadata', () => {
              track.duration = tempAudio.duration;
              track._metaLoaded = true;
              resolve();
            });
            tempAudio.addEventListener('error', () => {
              track._metaLoaded = true;
              resolve();
            });
          },
          onError: () => {
            const tempAudio = new Audio(track.url);
            tempAudio.addEventListener('loadedmetadata', () => {
              track.duration = tempAudio.duration;
              track._metaLoaded = true;
              resolve();
            });
            tempAudio.addEventListener('error', () => {
              track._metaLoaded = true;
              resolve();
            });
          }
        });
      });
    }

    // Update now playing bar
    function updateNowPlaying(track) {
      nowPlayingTitle.textContent = track.name;
      nowPlayingArtistAlbum.textContent = `${track.artist} ‚Äî ${track.album}`;
    }

    // Play/pause toggle
    function togglePlayPause() {
      if (!audio.src) return;
      if (isPlaying) {
        audio.pause();
        btnPlayPause.textContent = '‚ñ∂Ô∏è';
      } else {
        audio.play();
        btnPlayPause.textContent = '‚è∏Ô∏è';
      }
      isPlaying = !isPlaying;
    }

    // Play previous track respecting repeat/shuffle
    function playPrev() {
      if (queue.length === 0) return;
      if (repeatMode === 'one') {
        playTrack(currentTrackIndex);
        return;
      }
      if (currentTrackIndex === -1) return;

      if (isShuffle) {
        const randomIndex = Math.floor(Math.random() * filteredTracks.length);
        playTrack(randomIndex);
        return;
      }

      // Play previous in queue
      const currentQueueIdx = queue.findIndex(i => i === currentTrackIndex);
      let prevQueueIdx = currentQueueIdx - 1;
      if (prevQueueIdx < 0) {
        if (repeatMode === 'all') prevQueueIdx = queue.length - 1;
        else return;
      }
      playTrack(queue[prevQueueIdx]);
    }

    // Play next track respecting repeat/shuffle
    function playNext() {
      if (queue.length === 0) return;
      if (repeatMode === 'one') {
        playTrack(currentTrackIndex);
        return;
      }
      if (currentTrackIndex === -1) return;

      if (isShuffle) {
        const randomIndex = Math.floor(Math.random() * filteredTracks.length);
        playTrack(randomIndex);
        return;
      }

      // Play next in queue
      const currentQueueIdx = queue.findIndex(i => i === currentTrackIndex);
      let nextQueueIdx = currentQueueIdx + 1;
      if (nextQueueIdx >= queue.length) {
        if (repeatMode === 'all') nextQueueIdx = 0;
        else {
          audio.pause();
          isPlaying = false;
          btnPlayPause.textContent = '‚ñ∂Ô∏è';
          return;
        }
      }
      playTrack(queue[nextQueueIdx]);
    }

    // Update progress bar
    function updateProgress() {
      if (!audio.duration) return;
      const percent = (audio.currentTime / audio.duration) * 100;
      progressFilled.style.width = `${percent}%`;
      currentTimeEl.textContent = formatDuration(audio.currentTime);
      durationTimeEl.textContent = formatDuration(audio.duration);
      progressBar.setAttribute('aria-valuenow', Math.floor(percent));
    }

    // Seek audio on progress bar click
    function seekAudio(e) {
      const rect = progressBar.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const percent = clickX / rect.width;
      audio.currentTime = percent * audio.duration;
    }

    // Search filter
    function filterSongs() {
      const val = searchInput.value.toLowerCase();
      filteredTracks = tracks.filter(t =>
        t.name.toLowerCase().includes(val) ||
        t.artist.toLowerCase().includes(val) ||
        t.album.toLowerCase().includes(val)
      );
      resetQueue();
      renderSongList();
      renderQueue();
    }

    // Volume control
    function updateVolume(val) {
      audio.volume = val;
      volumeSlider.value = val;
      updateVolumeIcon();
    }

    // Update volume icon
    function updateVolumeIcon() {
      if (audio.muted || audio.volume === 0) {
        volumeIcon.textContent = 'üîá';
      } else if (audio.volume < 0.5) {
        volumeIcon.textContent = 'üîâ';
      } else {
        volumeIcon.textContent = 'üîä';
      }
    }

    // Toggle mute
    function toggleMute() {
      audio.muted = !audio.muted;
      updateVolumeIcon();
      if (!audio.muted) {
        volumeSlider.value = audio.volume;
      } else {
        volumeSlider.value = 0;
      }
    }

    // Toggle EQ dropdown
    function toggleEQDropdown() {
      const isVisible = eqDropdown.style.display === 'block';
      eqDropdown.style.display = isVisible ? 'none' : 'block';
      eqToggleBtn.setAttribute('aria-expanded', !isVisible);
      if (!isVisible && audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
    }

    // Update EQ filter gains
    function updateEQ() {
      bassFilter.gain.setValueAtTime(bassSlider.value, audioCtx.currentTime);
      trebleFilter.gain.setValueAtTime(trebleSlider.value, audioCtx.currentTime);
    }

    // Toggle theme light/dark
    function toggleTheme() {
      document.body.classList.toggle('light');
    }

    // Setup column sorting
    function setupSorting() {
      document.querySelectorAll('th.sortable').forEach(th => {
        th.addEventListener('click', () => {
          const field = th.getAttribute('data-sort');
          if (sortField === field) {
            sortDirection = (sortDirection === 'asc') ? 'desc' : 'asc';
          } else {
            sortField = field;
            sortDirection = 'asc';
          }
          document.querySelectorAll('th.sortable').forEach(header => {
            header.setAttribute('aria-sort', 'none');
            header.classList.remove('sorted-asc', 'sorted-desc');
          });
          th.setAttribute('aria-sort', sortDirection === 'asc' ? 'ascending' : 'descending');
          th.classList.add(sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');
          renderSongList();
        });
        th.addEventListener('keydown', e => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            th.click();
          }
        });
      });
    }

    // Setup keyboard navigation in song list and global shortcuts
    function setupKeyboardNavigation() {
      songTableBody.addEventListener('keydown', e => {
        if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
          e.preventDefault();
          const rows = [...songTableBody.querySelectorAll('tr')];
          if (!rows.length) return;
          let idx = rows.findIndex(r => r === document.activeElement);
          if (idx === -1) idx = 0;
          else idx = (e.key === 'ArrowDown') ? idx + 1 : idx - 1;
          if (idx < 0) idx = rows.length - 1;
          if (idx >= rows.length) idx = 0;
          rows[idx].focus();
        } else if (e.key === 'Enter') {
          e.preventDefault();
          const rows = [...songTableBody.querySelectorAll('tr')];
          const idx = rows.findIndex(r => r === document.activeElement);
          if (idx !== -1) playTrack(idx);
        }
      });

      // Global shortcuts
      document.addEventListener('keydown', e => {
        if (e.target.tagName === 'INPUT' || e.target.isContentEditable) return;
        if (e.code === 'Space') {
          e.preventDefault();
          togglePlayPause();
        } else if (e.code === 'ArrowRight') {
          e.preventDefault();
          playNext();
        } else if (e.code === 'ArrowLeft') {
          e.preventDefault();
          playPrev();
        }
      });
    }

    // Queue management
    // Initialize/reset queue to filteredTracks order
    function resetQueue() {
      queue = filteredTracks.map((_, i) => i);
      highlightQueueCurrent();
    }

    // Add a track to queue (if not already in)
    function addToQueue(trackIndex) {
      if (!queue.includes(trackIndex)) {
        queue.push(trackIndex);
      }
      renderQueue();
    }

    // Render queue list
    function renderQueue() {
      queueList.innerHTML = '';
      if (queue.length === 0) {
        queueList.innerHTML = '<li>No songs in queue</li>';
        return;
      }
      queue.forEach((trackIdx, i) => {
        const li = document.createElement('li');
        const track = filteredTracks[trackIdx];
        li.textContent = track ? track.name : 'Unknown track';
        li.className = (trackIdx === currentTrackIndex) ? 'active' : '';
        li.tabIndex = 0;
        li.setAttribute('role', 'button');
        li.addEventListener('click', () => {
          playTrack(trackIdx);
        });
        li.addEventListener('keydown', e => {
          if (e.key === 'Enter') {
            e.preventDefault();
            playTrack(trackIdx);
          }
        });
        queueList.appendChild(li);
      });
    }

    // Highlight currently playing in queue
    function highlightQueueCurrent() {
      [...queueList.children].forEach(li => li.classList.remove('active'));
      if (currentTrackIndex === -1) return;
      const idx = queue.findIndex(i => i === currentTrackIndex);
      if (idx !== -1 && queueList.children[idx]) {
        queueList.children[idx].classList.add('active');
        queueList.children[idx].scrollIntoView({ block: 'nearest', behavior: 'smooth' });
      }
    }

    // Shuffle toggle
    function toggleShuffle() {
      isShuffle = !isShuffle;
      btnShuffle.style.color = isShuffle ? '#1db954' : '';
    }

    // Cycle repeat mode
    function cycleRepeatMode() {
      if (repeatMode === 'none') {
        repeatMode = 'all';
        btnRepeat.textContent = 'üîÅ'; // Repeat all
      } else if (repeatMode === 'all') {
        repeatMode = 'one';
        btnRepeat.textContent = 'üîÇ'; // Repeat one
      } else {
        repeatMode = 'none';
        btnRepeat.textContent = 'üîÅ'; // No repeat (greyed)
        btnRepeat.style.color = '#ccc';
        setTimeout(() => { btnRepeat.style.color = ''; }, 200);
      }
    }

    // Setup event listeners
    function setupEventListeners() {
      toggleThemeBtn.addEventListener('click', toggleTheme);

      btnPlayPause.addEventListener('click', togglePlayPause);
      btnPrev.addEventListener('click', playPrev);
      btnNext.addEventListener('click', playNext);
      btnShuffle.addEventListener('click', toggleShuffle);
      btnRepeat.addEventListener('click', cycleRepeatMode);
      eqToggleBtn.addEventListener('click', toggleEQDropdown);

      bassSlider.addEventListener('input', updateEQ);
      trebleSlider.addEventListener('input', updateEQ);

      searchInput.addEventListener('input', filterSongs);

      volumeSlider.addEventListener('input', e => {
        updateVolume(e.target.value);
        audio.muted = false;
      });

      volumeIcon.addEventListener('click', toggleMute);

      audio.addEventListener('timeupdate', updateProgress);
      audio.addEventListener('ended', playNext);

      progressBar.addEventListener('click', seekAudio);

      // Close EQ dropdown on outside click
      document.addEventListener('click', (e) => {
        if (!eqDropdown.contains(e.target) && e.target !== eqToggleBtn) {
          eqDropdown.style.display = 'none';
          eqToggleBtn.setAttribute('aria-expanded', false);
        }
      });

      setupSorting();
      setupKeyboardNavigation();
    }

    // Initialization function
    async function init() {
      setupAudioContext();

      await loadSongsFromDrive();
      filteredTracks = [...tracks];

      // Preload metadata for all tracks (async but no need to await all)
      filteredTracks.forEach(t => {
        if (!t._metaLoaded) {
          loadMetadata(t).then(renderSongList);
        }
      });

      resetQueue();
      renderSongList();
      renderQueue();

      updateVolume(volumeSlider.value);

      setupEventListeners();
    }

    // Kickoff
    init();

  </script>
</body>
</html>
